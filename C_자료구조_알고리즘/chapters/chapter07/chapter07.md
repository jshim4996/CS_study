# Chapter 07. Stack (ìŠ¤íƒ)

## Table of Contents (ëª©ì°¨)
1. [Stack Concept - LIFO (ìŠ¤íƒ ê°œë… - í›„ì…ì„ ì¶œ)](#1-stack-concept---lifo-ìŠ¤íƒ-ê°œë…---í›„ì…ì„ ì¶œ)
2. [Stack Operations (ìŠ¤íƒ ì—°ì‚°)](#2-stack-operations-ìŠ¤íƒ-ì—°ì‚°)
3. [Array-based Stack (ë°°ì—´ ê¸°ë°˜ ìŠ¤íƒ)](#3-array-based-stack-ë°°ì—´-ê¸°ë°˜-ìŠ¤íƒ)
4. [Linked List-based Stack (ì—°ê²° ë¦¬ìŠ¤íŠ¸ ê¸°ë°˜ ìŠ¤íƒ)](#4-linked-list-based-stack-ì—°ê²°-ë¦¬ìŠ¤íŠ¸-ê¸°ë°˜-ìŠ¤íƒ)
5. [Applications (ì‘ìš©)](#5-applications-ì‘ìš©)
6. [Summary (ìš”ì•½)](#6-summary-ìš”ì•½)

---

## 1. Stack Concept - LIFO (ìŠ¤íƒ ê°œë… - í›„ì…ì„ ì¶œ)

### What is a Stack? (ìŠ¤íƒì´ë€?)

A **Stack** is a linear data structure that follows the **LIFO (Last In, First Out)** principle. The last element added to the stack is the first one to be removed.

**ìŠ¤íƒ**ì€ **LIFO (Last In, First Out - í›„ì…ì„ ì¶œ)** ì›ë¦¬ë¥¼ ë”°ë¥´ëŠ” ì„ í˜• ìë£Œ êµ¬ì¡°ì…ë‹ˆë‹¤. ìŠ¤íƒì— ë§ˆì§€ë§‰ìœ¼ë¡œ ì¶”ê°€ëœ ìš”ì†Œê°€ ê°€ì¥ ë¨¼ì € ì œê±°ë©ë‹ˆë‹¤.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      STACK CONCEPT (ìŠ¤íƒ ê°œë…)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚      LIFO: Last In, First Out (í›„ì…ì„ ì¶œ)                         â”‚
â”‚                                                                 â”‚
â”‚           â”‚         â”‚                                           â”‚
â”‚           â”‚    C    â”‚  â—€â”€â”€ Top (ìµœìƒë‹¨) - Last In, First Out    â”‚
â”‚           â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                                           â”‚
â”‚           â”‚    B    â”‚                                           â”‚
â”‚           â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                                           â”‚
â”‚           â”‚    A    â”‚  â—€â”€â”€ Bottom (ìµœí•˜ë‹¨) - First In, Last Out â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                           â”‚
â”‚                                                                 â”‚
â”‚      Real-world examples (ì‹¤ì œ ì˜ˆì‹œ):                            â”‚
â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚      â”‚  ğŸ“š Stack of books (ì±… ë”ë¯¸)                         â”‚   â”‚
â”‚      â”‚  ğŸ½ï¸  Stack of plates (ì ‘ì‹œ ë”ë¯¸)                     â”‚   â”‚
â”‚      â”‚  â†©ï¸  Undo operation (ì‹¤í–‰ ì·¨ì†Œ ê¸°ëŠ¥)                  â”‚   â”‚
â”‚      â”‚  ğŸ”™ Browser back button (ë¸Œë¼ìš°ì € ë’¤ë¡œ ê°€ê¸°)          â”‚   â”‚
â”‚      â”‚  ğŸ“ Function call stack (í•¨ìˆ˜ í˜¸ì¶œ ìŠ¤íƒ)             â”‚   â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Visual Example of LIFO (LIFO ì‹œê°ì  ì˜ˆì‹œ)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    LIFO DEMONSTRATION                           â”‚
â”‚                    (LIFO ì‹œì—°)                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   PUSH Order: A â†’ B â†’ C    (ì‚½ì… ìˆœì„œ: A â†’ B â†’ C)               â”‚
â”‚   POP Order:  C â†’ B â†’ A    (ì œê±° ìˆœì„œ: C â†’ B â†’ A)               â”‚
â”‚                                                                 â”‚
â”‚   Step 1       Step 2       Step 3       Step 4       Step 5    â”‚
â”‚   Push A       Push B       Push C       Pop C        Pop B     â”‚
â”‚                                                                 â”‚
â”‚   â”‚     â”‚     â”‚     â”‚     â”‚  C  â”‚     â”‚     â”‚     â”‚     â”‚      â”‚
â”‚   â”‚     â”‚     â”‚  B  â”‚     â”‚  B  â”‚     â”‚  B  â”‚     â”‚     â”‚      â”‚
â”‚   â”‚  A  â”‚     â”‚  A  â”‚     â”‚  A  â”‚     â”‚  A  â”‚     â”‚  A  â”‚      â”‚
â”‚   â””â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                                 â”‚
â”‚   top=0       top=1       top=2       top=1       top=0        â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Stack Operations (ìŠ¤íƒ ì—°ì‚°)

### Basic Operations (ê¸°ë³¸ ì—°ì‚°)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   STACK OPERATIONS (ìŠ¤íƒ ì—°ì‚°)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Operation    Description              Time       Korean        â”‚
â”‚  (ì—°ì‚°)       (ì„¤ëª…)                   (ì‹œê°„)     (í•œêµ­ì–´)       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                 â”‚
â”‚  push(x)     Add element x to top     O(1)       ìš”ì†Œ xë¥¼ topì— â”‚
â”‚                                                  ì¶”ê°€           â”‚
â”‚                                                                 â”‚
â”‚  pop()       Remove top element       O(1)       top ìš”ì†Œ ì œê±°  â”‚
â”‚              and return it                       ë° ë°˜í™˜        â”‚
â”‚                                                                 â”‚
â”‚  peek()/     Return top element       O(1)       top ìš”ì†Œ ë°˜í™˜  â”‚
â”‚  top()       without removing                    (ì œê±° ì—†ì´)    â”‚
â”‚                                                                 â”‚
â”‚  isEmpty()   Check if stack is        O(1)       ìŠ¤íƒì´ ë¹„ì—ˆëŠ”ì§€â”‚
â”‚              empty                               í™•ì¸           â”‚
â”‚                                                                 â”‚
â”‚  isFull()    Check if stack is        O(1)       ìŠ¤íƒì´ ê°€ë“    â”‚
â”‚              full (array only)                   ì°¼ëŠ”ì§€ í™•ì¸    â”‚
â”‚                                                                 â”‚
â”‚  size()      Return number of         O(1)       ìš”ì†Œ ê°œìˆ˜ ë°˜í™˜ â”‚
â”‚              elements                                           â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Push Operation (Push ì—°ì‚°)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PUSH OPERATION (Push ì—°ì‚°)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Before push(40):              After push(40):                  â”‚
â”‚  push(40) ì „:                  push(40) í›„:                     â”‚
â”‚                                                                 â”‚
â”‚       â”‚     â”‚                       â”‚  40 â”‚ â—€â”€â”€ new top        â”‚
â”‚  topâ†’ â”‚  30 â”‚                       â”‚â”€â”€â”€â”€â”€â”‚                     â”‚
â”‚       â”‚â”€â”€â”€â”€â”€â”‚                       â”‚  30 â”‚                     â”‚
â”‚       â”‚  20 â”‚                       â”‚â”€â”€â”€â”€â”€â”‚                     â”‚
â”‚       â”‚â”€â”€â”€â”€â”€â”‚                       â”‚  20 â”‚                     â”‚
â”‚       â”‚  10 â”‚                       â”‚â”€â”€â”€â”€â”€â”‚                     â”‚
â”‚       â””â”€â”€â”€â”€â”€â”˜                       â”‚  10 â”‚                     â”‚
â”‚                                     â””â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                                                                 â”‚
â”‚  Algorithm (ì•Œê³ ë¦¬ì¦˜):                                           â”‚
â”‚  1. Check if stack is full (ìŠ¤íƒì´ ê°€ë“ ì°¼ëŠ”ì§€ í™•ì¸)             â”‚
â”‚  2. Increment top (top ì¦ê°€)                                    â”‚
â”‚  3. Place element at top position (top ìœ„ì¹˜ì— ìš”ì†Œ ë°°ì¹˜)         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Pop Operation (Pop ì—°ì‚°)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     POP OPERATION (Pop ì—°ì‚°)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Before pop():                 After pop():     Return: 30      â”‚
â”‚  pop() ì „:                     pop() í›„:        ë°˜í™˜ê°’: 30      â”‚
â”‚                                                                 â”‚
â”‚  topâ†’ â”‚  30 â”‚ â”€â”€â”€ removed           â”‚     â”‚                     â”‚
â”‚       â”‚â”€â”€â”€â”€â”€â”‚                  topâ†’ â”‚  20 â”‚                     â”‚
â”‚       â”‚  20 â”‚                       â”‚â”€â”€â”€â”€â”€â”‚                     â”‚
â”‚       â”‚â”€â”€â”€â”€â”€â”‚                       â”‚  10 â”‚                     â”‚
â”‚       â”‚  10 â”‚                       â””â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚       â””â”€â”€â”€â”€â”€â”˜                                                   â”‚
â”‚                                                                 â”‚
â”‚  Algorithm (ì•Œê³ ë¦¬ì¦˜):                                           â”‚
â”‚  1. Check if stack is empty (ìŠ¤íƒì´ ë¹„ì—ˆëŠ”ì§€ í™•ì¸)               â”‚
â”‚  2. Get element at top (topì˜ ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°)                     â”‚
â”‚  3. Decrement top (top ê°ì†Œ)                                    â”‚
â”‚  4. Return the element (ìš”ì†Œ ë°˜í™˜)                               â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. Array-based Stack (ë°°ì—´ ê¸°ë°˜ ìŠ¤íƒ)

### Implementation (êµ¬í˜„)

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_SIZE 100

// Array-based Stack structure (ë°°ì—´ ê¸°ë°˜ ìŠ¤íƒ êµ¬ì¡°)
typedef struct {
    int data[MAX_SIZE];  // Array to store elements (ìš”ì†Œ ì €ì¥ ë°°ì—´)
    int top;             // Index of top element (top ìš”ì†Œì˜ ì¸ë±ìŠ¤)
} Stack;

// Initialize stack (ìŠ¤íƒ ì´ˆê¸°í™”)
void initStack(Stack* s) {
    s->top = -1;  // Empty stack has top = -1 (ë¹ˆ ìŠ¤íƒì€ top = -1)
}

// Check if stack is empty (ìŠ¤íƒì´ ë¹„ì—ˆëŠ”ì§€ í™•ì¸)
bool isEmpty(Stack* s) {
    return s->top == -1;
}

// Check if stack is full (ìŠ¤íƒì´ ê°€ë“ ì°¼ëŠ”ì§€ í™•ì¸)
bool isFull(Stack* s) {
    return s->top == MAX_SIZE - 1;
}

// Push element onto stack (ìŠ¤íƒì— ìš”ì†Œ ì¶”ê°€)
bool push(Stack* s, int value) {
    if (isFull(s)) {
        printf("Stack Overflow! Cannot push %d\n", value);
        return false;
    }
    s->data[++s->top] = value;  // Increment top, then add element
                                 // top ì¦ê°€ í›„ ìš”ì†Œ ì¶”ê°€
    return true;
}

// Pop element from stack (ìŠ¤íƒì—ì„œ ìš”ì†Œ ì œê±°)
int pop(Stack* s) {
    if (isEmpty(s)) {
        printf("Stack Underflow! Cannot pop\n");
        return -1;  // Error value (ì—ëŸ¬ ê°’)
    }
    return s->data[s->top--];  // Return element, then decrement top
                                // ìš”ì†Œ ë°˜í™˜ í›„ top ê°ì†Œ
}

// Peek at top element without removing (ì œê±° ì—†ì´ top ìš”ì†Œ í™•ì¸)
int peek(Stack* s) {
    if (isEmpty(s)) {
        printf("Stack is empty!\n");
        return -1;
    }
    return s->data[s->top];
}

// Get stack size (ìŠ¤íƒ í¬ê¸° ë°˜í™˜)
int size(Stack* s) {
    return s->top + 1;
}

// Print stack contents (ìŠ¤íƒ ë‚´ìš© ì¶œë ¥)
void printStack(Stack* s) {
    if (isEmpty(s)) {
        printf("Stack is empty\n");
        return;
    }
    printf("Stack (bottom to top): ");
    for (int i = 0; i <= s->top; i++) {
        printf("%d ", s->data[i]);
    }
    printf("\n");
}
```

### Array-based Stack Memory Layout (ë°°ì—´ ê¸°ë°˜ ìŠ¤íƒ ë©”ëª¨ë¦¬ êµ¬ì¡°)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            ARRAY-BASED STACK MEMORY (ë°°ì—´ ê¸°ë°˜ ìŠ¤íƒ ë©”ëª¨ë¦¬)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Stack with MAX_SIZE = 8 and 4 elements pushed:                 â”‚
â”‚  MAX_SIZE = 8ì´ê³  4ê°œ ìš”ì†Œê°€ pushëœ ìŠ¤íƒ:                        â”‚
â”‚                                                                 â”‚
â”‚  Index:    [0]    [1]    [2]    [3]    [4]    [5]    [6]    [7] â”‚
â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚  data:   â”‚  10  â”‚  20  â”‚  30  â”‚  40  â”‚  --  â”‚  --  â”‚  --  â”‚  -- â”‚
â”‚          â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
â”‚            â–²                    â–²      â–²                         â”‚
â”‚            â”‚                    â”‚      â”‚                         â”‚
â”‚         Bottom               Top   Unused space                  â”‚
â”‚         (ë°”ë‹¥)              (top=3) (ë¯¸ì‚¬ìš© ê³µê°„)                 â”‚
â”‚                                                                 â”‚
â”‚  Advantages (ì¥ì ):                                              â”‚
â”‚  â€¢ Simple implementation (ê°„ë‹¨í•œ êµ¬í˜„)                           â”‚
â”‚  â€¢ Cache-friendly (ìºì‹œ ì¹œí™”ì )                                  â”‚
â”‚  â€¢ O(1) for all operations (ëª¨ë“  ì—°ì‚° O(1))                      â”‚
â”‚                                                                 â”‚
â”‚  Disadvantages (ë‹¨ì ):                                           â”‚
â”‚  â€¢ Fixed size (ê³ ì • í¬ê¸°)                                        â”‚
â”‚  â€¢ May waste memory (ë©”ëª¨ë¦¬ ë‚­ë¹„ ê°€ëŠ¥)                           â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Complete Example (ì™„ì „í•œ ì˜ˆì œ)

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int top;
} Stack;

void initStack(Stack* s) { s->top = -1; }
bool isEmpty(Stack* s) { return s->top == -1; }
bool isFull(Stack* s) { return s->top == MAX_SIZE - 1; }

bool push(Stack* s, int value) {
    if (isFull(s)) {
        printf("Stack Overflow!\n");
        return false;
    }
    s->data[++s->top] = value;
    return true;
}

int pop(Stack* s) {
    if (isEmpty(s)) {
        printf("Stack Underflow!\n");
        return -1;
    }
    return s->data[s->top--];
}

int peek(Stack* s) {
    if (isEmpty(s)) return -1;
    return s->data[s->top];
}

void printStack(Stack* s) {
    printf("Stack: ");
    for (int i = 0; i <= s->top; i++) {
        printf("%d ", s->data[i]);
    }
    printf("| top = %d\n", s->top);
}

int main() {
    Stack s;
    initStack(&s);

    printf("=== Array-based Stack Demo ===\n");
    printf("=== ë°°ì—´ ê¸°ë°˜ ìŠ¤íƒ ë°ëª¨ ===\n\n");

    // Push elements (ìš”ì†Œ ì¶”ê°€)
    push(&s, 10);
    push(&s, 20);
    push(&s, 30);
    printStack(&s);  // Stack: 10 20 30 | top = 2

    // Peek (top í™•ì¸)
    printf("Peek: %d\n", peek(&s));  // 30

    // Pop elements (ìš”ì†Œ ì œê±°)
    printf("Pop: %d\n", pop(&s));  // 30
    printf("Pop: %d\n", pop(&s));  // 20
    printStack(&s);  // Stack: 10 | top = 0

    // Check empty (ë¹ˆ ìƒíƒœ í™•ì¸)
    printf("isEmpty: %s\n", isEmpty(&s) ? "true" : "false");  // false

    pop(&s);
    printf("isEmpty after all pops: %s\n",
           isEmpty(&s) ? "true" : "false");  // true

    return 0;
}
```

---

## 4. Linked List-based Stack (ì—°ê²° ë¦¬ìŠ¤íŠ¸ ê¸°ë°˜ ìŠ¤íƒ)

### Implementation (êµ¬í˜„)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         LINKED LIST-BASED STACK (ì—°ê²° ë¦¬ìŠ¤íŠ¸ ê¸°ë°˜ ìŠ¤íƒ)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  top                                                            â”‚
â”‚   â”‚                                                             â”‚
â”‚   â–¼                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚  30  â”‚   â—â”€â”€â”¼â”€â”€â”€â–¶â”‚  20  â”‚   â—â”€â”€â”¼â”€â”€â”€â–¶â”‚  10  â”‚ NULL â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                 â”‚
â”‚  Push adds new node at top (PushëŠ” topì— ìƒˆ ë…¸ë“œ ì¶”ê°€)          â”‚
â”‚  Pop removes node from top (Popì€ topì—ì„œ ë…¸ë“œ ì œê±°)            â”‚
â”‚                                                                 â”‚
â”‚  Advantages (ì¥ì ):                                              â”‚
â”‚  â€¢ Dynamic size (ë™ì  í¬ê¸°)                                      â”‚
â”‚  â€¢ No overflow (unless memory exhausted)                        â”‚
â”‚    (ë©”ëª¨ë¦¬ ì†Œì§„ ì „ê¹Œì§€ ì˜¤ë²„í”Œë¡œìš° ì—†ìŒ)                          â”‚
â”‚                                                                 â”‚
â”‚  Disadvantages (ë‹¨ì ):                                           â”‚
â”‚  â€¢ Extra memory for pointers (í¬ì¸í„°ì— ì¶”ê°€ ë©”ëª¨ë¦¬)              â”‚
â”‚  â€¢ Not cache-friendly (ìºì‹œ ë¹„ì¹œí™”ì )                            â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// Node structure (ë…¸ë“œ êµ¬ì¡°)
typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Linked List Stack structure (ì—°ê²° ë¦¬ìŠ¤íŠ¸ ìŠ¤íƒ êµ¬ì¡°)
typedef struct {
    Node* top;  // Pointer to top node (top ë…¸ë“œ í¬ì¸í„°)
    int size;   // Number of elements (ìš”ì†Œ ê°œìˆ˜)
} LLStack;

// Initialize stack (ìŠ¤íƒ ì´ˆê¸°í™”)
void initLLStack(LLStack* s) {
    s->top = NULL;
    s->size = 0;
}

// Check if stack is empty (ìŠ¤íƒì´ ë¹„ì—ˆëŠ”ì§€ í™•ì¸)
bool llIsEmpty(LLStack* s) {
    return s->top == NULL;
}

// Push element onto stack - O(1) (ìŠ¤íƒì— ìš”ì†Œ ì¶”ê°€ - O(1))
bool llPush(LLStack* s, int value) {
    // Create new node (ìƒˆ ë…¸ë“œ ìƒì„±)
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (newNode == NULL) {
        printf("Memory allocation failed!\n");
        return false;
    }

    newNode->data = value;
    newNode->next = s->top;  // Point to current top (í˜„ì¬ top ê°€ë¦¬í‚´)
    s->top = newNode;        // New node becomes top (ìƒˆ ë…¸ë“œê°€ topì´ ë¨)
    s->size++;
    return true;
}

// Pop element from stack - O(1) (ìŠ¤íƒì—ì„œ ìš”ì†Œ ì œê±° - O(1))
int llPop(LLStack* s) {
    if (llIsEmpty(s)) {
        printf("Stack Underflow!\n");
        return -1;
    }

    Node* temp = s->top;
    int value = temp->data;
    s->top = s->top->next;  // Move top to next node (topì„ ë‹¤ìŒ ë…¸ë“œë¡œ ì´ë™)
    free(temp);              // Free old top node (ì´ì „ top ë…¸ë“œ í•´ì œ)
    s->size--;
    return value;
}

// Peek at top element - O(1) (top ìš”ì†Œ í™•ì¸ - O(1))
int llPeek(LLStack* s) {
    if (llIsEmpty(s)) {
        printf("Stack is empty!\n");
        return -1;
    }
    return s->top->data;
}

// Get stack size - O(1) (ìŠ¤íƒ í¬ê¸° ë°˜í™˜ - O(1))
int llSize(LLStack* s) {
    return s->size;
}

// Print stack (ìŠ¤íƒ ì¶œë ¥)
void printLLStack(LLStack* s) {
    if (llIsEmpty(s)) {
        printf("Stack is empty\n");
        return;
    }
    printf("Stack (top to bottom): ");
    Node* current = s->top;
    while (current != NULL) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}

// Free all memory (ëª¨ë“  ë©”ëª¨ë¦¬ í•´ì œ)
void freeLLStack(LLStack* s) {
    while (!llIsEmpty(s)) {
        llPop(s);
    }
}
```

### Push Operation Visualization (Push ì—°ì‚° ì‹œê°í™”)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              LINKED LIST PUSH OPERATION                         â”‚
â”‚              (ì—°ê²° ë¦¬ìŠ¤íŠ¸ Push ì—°ì‚°)                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Before push(40):                                               â”‚
â”‚  push(40) ì „:                                                   â”‚
â”‚                                                                 â”‚
â”‚     top                                                         â”‚
â”‚      â”‚                                                          â”‚
â”‚      â–¼                                                          â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚    â”‚  30  â”‚   â—â”€â”€â”¼â”€â”€â”€â–¶â”‚  20  â”‚ NULL â”‚                          â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                                                                 â”‚
â”‚  After push(40):                                                â”‚
â”‚  push(40) í›„:                                                   â”‚
â”‚                                                                 â”‚
â”‚     top (new)                                                   â”‚
â”‚      â”‚                                                          â”‚
â”‚      â–¼                                                          â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚    â”‚  40  â”‚   â—â”€â”€â”¼â”€â”€â”€â–¶â”‚  30  â”‚   â—â”€â”€â”¼â”€â”€â”€â–¶â”‚  20  â”‚ NULL â”‚       â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚      NEW NODE                                                   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 5. Applications (ì‘ìš©)

### Application 1: Bracket Matching (ê´„í˜¸ ì§ ë§ì¶”ê¸°)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            BRACKET MATCHING (ê´„í˜¸ ì§ ë§ì¶”ê¸°)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Valid expressions (ìœ íš¨í•œ í‘œí˜„ì‹):                              â”‚
â”‚    â€¢ ( )              âœ“                                         â”‚
â”‚    â€¢ ( ( ) )          âœ“                                         â”‚
â”‚    â€¢ ( ) { } [ ]      âœ“                                         â”‚
â”‚    â€¢ { [ ( ) ] }      âœ“                                         â”‚
â”‚                                                                 â”‚
â”‚  Invalid expressions (ìœ íš¨í•˜ì§€ ì•Šì€ í‘œí˜„ì‹):                     â”‚
â”‚    â€¢ ( ( )            âœ—  (missing closing)                      â”‚
â”‚    â€¢ ( ) )            âœ—  (extra closing)                        â”‚
â”‚    â€¢ ( ] )            âœ—  (mismatched type)                      â”‚
â”‚    â€¢ { [ ( ] ) }      âœ—  (wrong order)                          â”‚
â”‚                                                                 â”‚
â”‚  Algorithm (ì•Œê³ ë¦¬ì¦˜):                                           â”‚
â”‚  1. Scan expression left to right (í‘œí˜„ì‹ì„ ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ) â”‚
â”‚  2. Push opening brackets onto stack (ì—¬ëŠ” ê´„í˜¸ë¥¼ ìŠ¤íƒì— push)   â”‚
â”‚  3. For closing bracket: (ë‹«ëŠ” ê´„í˜¸ê°€ ë‚˜ì˜¤ë©´:)                   â”‚
â”‚     - Check if stack is empty â†’ invalid                         â”‚
â”‚       (ìŠ¤íƒì´ ë¹„ì—ˆìœ¼ë©´ â†’ ìœ íš¨í•˜ì§€ ì•ŠìŒ)                          â”‚
â”‚     - Pop and check if brackets match                           â”‚
â”‚       (popí•˜ê³  ê´„í˜¸ê°€ ë§ëŠ”ì§€ í™•ì¸)                               â”‚
â”‚  4. After scanning, stack should be empty                       â”‚
â”‚     (ìŠ¤ìº” í›„ ìŠ¤íƒì´ ë¹„ì–´ìˆì–´ì•¼ í•¨)                               â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#define MAX_SIZE 100

typedef struct {
    char data[MAX_SIZE];
    int top;
} CharStack;

void initCharStack(CharStack* s) { s->top = -1; }
bool isCharEmpty(CharStack* s) { return s->top == -1; }
bool isCharFull(CharStack* s) { return s->top == MAX_SIZE - 1; }

void pushChar(CharStack* s, char c) {
    if (!isCharFull(s)) {
        s->data[++s->top] = c;
    }
}

char popChar(CharStack* s) {
    if (isCharEmpty(s)) return '\0';
    return s->data[s->top--];
}

// Check if brackets match (ê´„í˜¸ ì§ì´ ë§ëŠ”ì§€ í™•ì¸)
bool isMatchingPair(char open, char close) {
    return (open == '(' && close == ')') ||
           (open == '{' && close == '}') ||
           (open == '[' && close == ']');
}

// Check if brackets are balanced (ê´„í˜¸ê°€ ê· í˜• ì¡í˜”ëŠ”ì§€ í™•ì¸)
bool isBalanced(const char* expr) {
    CharStack stack;
    initCharStack(&stack);

    for (int i = 0; expr[i] != '\0'; i++) {
        char c = expr[i];

        // If opening bracket, push to stack
        // ì—¬ëŠ” ê´„í˜¸ë©´ ìŠ¤íƒì— push
        if (c == '(' || c == '{' || c == '[') {
            pushChar(&stack, c);
        }
        // If closing bracket, check for match
        // ë‹«ëŠ” ê´„í˜¸ë©´ ì§ í™•ì¸
        else if (c == ')' || c == '}' || c == ']') {
            if (isCharEmpty(&stack)) {
                return false;  // No matching opening bracket
                               // ì§ì´ ë§ëŠ” ì—¬ëŠ” ê´„í˜¸ ì—†ìŒ
            }
            char top = popChar(&stack);
            if (!isMatchingPair(top, c)) {
                return false;  // Brackets don't match
                               // ê´„í˜¸ ì§ì´ ë§ì§€ ì•ŠìŒ
            }
        }
    }

    // Stack should be empty if balanced
    // ê· í˜•ì´ ë§ìœ¼ë©´ ìŠ¤íƒì´ ë¹„ì–´ìˆì–´ì•¼ í•¨
    return isCharEmpty(&stack);
}

// Demonstration
int main() {
    const char* expressions[] = {
        "{[()]}",      // Valid (ìœ íš¨)
        "([)]",        // Invalid (ìœ íš¨í•˜ì§€ ì•ŠìŒ)
        "((()))",      // Valid
        "{{{{",        // Invalid
        "{[](())}"     // Valid
    };

    printf("=== Bracket Matching Demo ===\n");
    printf("=== ê´„í˜¸ ì§ ë§ì¶”ê¸° ë°ëª¨ ===\n\n");

    for (int i = 0; i < 5; i++) {
        printf("Expression: %s -> %s\n",
               expressions[i],
               isBalanced(expressions[i]) ? "Balanced (ê· í˜•)" : "Not Balanced (ë¶ˆê· í˜•)");
    }

    return 0;
}
```

### Bracket Matching Trace Example (ê´„í˜¸ ì§ ë§ì¶”ê¸° ì¶”ì  ì˜ˆì‹œ)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       BRACKET MATCHING TRACE: "{[()]}"                          â”‚
â”‚       (ê´„í˜¸ ì§ ë§ì¶”ê¸° ì¶”ì : "{[()]}")                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Char   Action          Stack          Status                   â”‚
â”‚  ë¬¸ì   ë™ì‘            ìŠ¤íƒ           ìƒíƒœ                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚   {     push '{'        { }            Continue                 â”‚
â”‚   [     push '['        { [ }          Continue                 â”‚
â”‚   (     push '('        { [ ( }        Continue                 â”‚
â”‚   )     pop, match '('  { [ }          Match! âœ“                 â”‚
â”‚   ]     pop, match '['  { }            Match! âœ“                 â”‚
â”‚   }     pop, match '{'  (empty)        Match! âœ“                 â”‚
â”‚   END   check empty     (empty)        Valid! âœ“                 â”‚
â”‚                                                                 â”‚
â”‚  Result: Balanced (ê²°ê³¼: ê· í˜•)                                   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Application 2: Postfix Notation Evaluation (í›„ìœ„ í‘œê¸°ë²• ê³„ì‚°)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         POSTFIX NOTATION (í›„ìœ„ í‘œê¸°ë²•)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Notation Types (í‘œê¸°ë²• ì¢…ë¥˜):                                   â”‚
â”‚                                                                 â”‚
â”‚  â€¢ Infix:    a + b        (ì¤‘ìœ„: ì—°ì‚°ìê°€ í”¼ì—°ì‚°ì ì‚¬ì´)         â”‚
â”‚  â€¢ Prefix:   + a b        (ì „ìœ„: ì—°ì‚°ìê°€ í”¼ì—°ì‚°ì ì•)           â”‚
â”‚  â€¢ Postfix:  a b +        (í›„ìœ„: ì—°ì‚°ìê°€ í”¼ì—°ì‚°ì ë’¤)           â”‚
â”‚                                                                 â”‚
â”‚  Examples (ì˜ˆì‹œ):                                                â”‚
â”‚                                                                 â”‚
â”‚  Infix              Postfix                                     â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                      â”‚
â”‚  3 + 4              3 4 +                                       â”‚
â”‚  3 + 4 * 5          3 4 5 * +                                   â”‚
â”‚  (3 + 4) * 5        3 4 + 5 *                                   â”‚
â”‚  3 * 4 + 5 * 6      3 4 * 5 6 * +                               â”‚
â”‚                                                                 â”‚
â”‚  Why Postfix? (ì™œ í›„ìœ„ í‘œê¸°ë²•?)                                  â”‚
â”‚  â€¢ No parentheses needed (ê´„í˜¸ ë¶ˆí•„ìš”)                           â”‚
â”‚  â€¢ No operator precedence rules (ì—°ì‚°ì ìš°ì„ ìˆœìœ„ ê·œì¹™ ë¶ˆí•„ìš”)    â”‚
â”‚  â€¢ Easy to evaluate with stack (ìŠ¤íƒìœ¼ë¡œ ì‰½ê²Œ ê³„ì‚°)              â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>

#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int top;
} Stack;

void initStack(Stack* s) { s->top = -1; }
bool isEmpty(Stack* s) { return s->top == -1; }
void push(Stack* s, int val) { s->data[++s->top] = val; }
int pop(Stack* s) { return s->data[s->top--]; }

// Evaluate postfix expression (í›„ìœ„ í‘œí˜„ì‹ ê³„ì‚°)
int evaluatePostfix(const char* expr) {
    Stack stack;
    initStack(&stack);

    for (int i = 0; expr[i] != '\0'; i++) {
        char c = expr[i];

        // Skip spaces (ê³µë°± ê±´ë„ˆë›°ê¸°)
        if (c == ' ') continue;

        // If digit, push to stack (ìˆ«ìë©´ ìŠ¤íƒì— push)
        if (isdigit(c)) {
            push(&stack, c - '0');  // Convert char to int
        }
        // If operator, pop two operands and apply
        // ì—°ì‚°ìë©´ ë‘ í”¼ì—°ì‚°ìë¥¼ popí•˜ê³  ì—°ì‚° ì ìš©
        else {
            int b = pop(&stack);  // Second operand (ë‘ ë²ˆì§¸ í”¼ì—°ì‚°ì)
            int a = pop(&stack);  // First operand (ì²« ë²ˆì§¸ í”¼ì—°ì‚°ì)
            int result;

            switch (c) {
                case '+': result = a + b; break;
                case '-': result = a - b; break;
                case '*': result = a * b; break;
                case '/': result = a / b; break;
                default: result = 0;
            }

            push(&stack, result);  // Push result back
                                    // ê²°ê³¼ë¥¼ ë‹¤ì‹œ push
        }
    }

    return pop(&stack);  // Final result (ìµœì¢… ê²°ê³¼)
}

int main() {
    printf("=== Postfix Evaluation Demo ===\n");
    printf("=== í›„ìœ„ í‘œê¸°ë²• ê³„ì‚° ë°ëª¨ ===\n\n");

    // 3 + 4 = 7
    printf("3 4 + = %d\n", evaluatePostfix("3 4 +"));

    // 3 + 4 * 5 = 3 + 20 = 23
    printf("3 4 5 * + = %d\n", evaluatePostfix("3 4 5 * +"));

    // (3 + 4) * 5 = 7 * 5 = 35
    printf("3 4 + 5 * = %d\n", evaluatePostfix("3 4 + 5 *"));

    // 2 * 3 + 4 * 5 = 6 + 20 = 26
    printf("2 3 * 4 5 * + = %d\n", evaluatePostfix("2 3 * 4 5 * +"));

    return 0;
}
```

### Postfix Evaluation Trace (í›„ìœ„ í‘œê¸°ë²• ê³„ì‚° ì¶”ì )

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       POSTFIX EVALUATION TRACE: "3 4 5 * +"                     â”‚
â”‚       (í›„ìœ„ í‘œê¸°ë²• ê³„ì‚° ì¶”ì : "3 4 5 * +")                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  This is: 3 + (4 * 5) = 3 + 20 = 23                            â”‚
â”‚  ì´ê²ƒì€: 3 + (4 * 5) = 3 + 20 = 23                             â”‚
â”‚                                                                 â”‚
â”‚  Token   Action              Stack         Description          â”‚
â”‚  í† í°    ë™ì‘                ìŠ¤íƒ          ì„¤ëª…                  â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚   3      push 3              [3]           Push operand         â”‚
â”‚   4      push 4              [3, 4]        Push operand         â”‚
â”‚   5      push 5              [3, 4, 5]     Push operand         â”‚
â”‚   *      pop 5, 4            [3]           4 * 5 = 20           â”‚
â”‚          push 20             [3, 20]                            â”‚
â”‚   +      pop 20, 3           []            3 + 20 = 23          â”‚
â”‚          push 23             [23]                               â”‚
â”‚   END    pop result          []            Result = 23          â”‚
â”‚                                                                 â”‚
â”‚  Final Result: 23 (ìµœì¢… ê²°ê³¼: 23)                               â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 6. Summary (ìš”ì•½)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CHAPTER 07 SUMMARY (ìš”ì•½)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  STACK CONCEPT (ìŠ¤íƒ ê°œë…)                                       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  â€¢ LIFO: Last In, First Out (í›„ì…ì„ ì¶œ)                          â”‚
â”‚  â€¢ Elements added/removed only at top (topì—ì„œë§Œ ì¶”ê°€/ì œê±°)      â”‚
â”‚  â€¢ Like a stack of plates (ì ‘ì‹œ ë”ë¯¸ì™€ ê°™ìŒ)                     â”‚
â”‚                                                                 â”‚
â”‚  OPERATIONS (ì—°ì‚°)                                               â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  â€¢ push(x): Add x to top - O(1)                                 â”‚
â”‚  â€¢ pop():   Remove from top - O(1)                              â”‚
â”‚  â€¢ peek():  View top without removing - O(1)                    â”‚
â”‚  â€¢ isEmpty(): Check if empty - O(1)                             â”‚
â”‚                                                                 â”‚
â”‚  IMPLEMENTATIONS (êµ¬í˜„)                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                 â”‚
â”‚  Array-based (ë°°ì—´ ê¸°ë°˜):                                        â”‚
â”‚  âœ“ Simple, cache-friendly                                       â”‚
â”‚  âœ“ ê°„ë‹¨í•¨, ìºì‹œ ì¹œí™”ì                                           â”‚
â”‚  âœ— Fixed size, may overflow                                     â”‚
â”‚  âœ— ê³ ì • í¬ê¸°, ì˜¤ë²„í”Œë¡œìš° ê°€ëŠ¥                                   â”‚
â”‚                                                                 â”‚
â”‚  Linked List-based (ì—°ê²° ë¦¬ìŠ¤íŠ¸ ê¸°ë°˜):                           â”‚
â”‚  âœ“ Dynamic size, no overflow                                    â”‚
â”‚  âœ“ ë™ì  í¬ê¸°, ì˜¤ë²„í”Œë¡œìš° ì—†ìŒ                                   â”‚
â”‚  âœ— Extra memory for pointers                                    â”‚
â”‚  âœ— í¬ì¸í„°ì— ì¶”ê°€ ë©”ëª¨ë¦¬ í•„ìš”                                    â”‚
â”‚                                                                 â”‚
â”‚  APPLICATIONS (ì‘ìš©)                                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  â€¢ Bracket matching (ê´„í˜¸ ì§ ë§ì¶”ê¸°)                             â”‚
â”‚  â€¢ Postfix evaluation (í›„ìœ„ í‘œê¸°ë²• ê³„ì‚°)                         â”‚
â”‚  â€¢ Function call stack (í•¨ìˆ˜ í˜¸ì¶œ ìŠ¤íƒ)                         â”‚
â”‚  â€¢ Undo operations (ì‹¤í–‰ ì·¨ì†Œ)                                   â”‚
â”‚  â€¢ Browser history (ë¸Œë¼ìš°ì € íˆìŠ¤í† ë¦¬)                           â”‚
â”‚  â€¢ Recursion implementation (ì¬ê·€ êµ¬í˜„)                          â”‚
â”‚                                                                 â”‚
â”‚  KEY POINTS (í•µì‹¬ í¬ì¸íŠ¸)                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  â€¢ All operations are O(1) constant time                        â”‚
â”‚  â€¢ ëª¨ë“  ì—°ì‚°ì´ O(1) ìƒìˆ˜ ì‹œê°„                                   â”‚
â”‚  â€¢ Stack is fundamental for many algorithms                     â”‚
â”‚  â€¢ ìŠ¤íƒì€ ë§ì€ ì•Œê³ ë¦¬ì¦˜ì˜ ê¸°ë³¸                                  â”‚
â”‚  â€¢ Choose implementation based on needs                         â”‚
â”‚  â€¢ í•„ìš”ì— ë”°ë¼ êµ¬í˜„ ë°©ì‹ ì„ íƒ                                   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Quick Reference (ë¹ ë¥¸ ì°¸ì¡°)

| Operation | Array Stack | Linked List Stack |
|-----------|-------------|-------------------|
| push | O(1) | O(1) |
| pop | O(1) | O(1) |
| peek | O(1) | O(1) |
| isEmpty | O(1) | O(1) |
| Space | Fixed | Dynamic |
